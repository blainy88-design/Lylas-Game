<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lyla's Game â€” City Street Run</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html, body { height: 100%; margin: 0; background:#0b1320; color:#fff; font-family: system-ui, Arial, sans-serif; touch-action: none; }
    canvas { display:block; }
    /* HUD */
    #hud { position: fixed; inset: 0; pointer-events: none; }
    #top { margin: 10px auto 0; width: max-content; background: linear-gradient(135deg, #ff9a9e, #fad0c4);
           color:#111; padding: 8px 16px; border-radius: 20px; font-weight: 800; box-shadow: 0 4px 18px rgba(0,0,0,.35); }
    #top .pill { background: rgba(255,255,255,.85); padding: 4px 10px; border-radius: 999px; margin: 0 6px; display:inline-block; min-width: 90px; text-align:center; }
    #msg { position: fixed; top: 56px; left: 50%; transform: translateX(-50%); font-weight:700; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
    /* Touch controls */
    #controls { position: fixed; inset: 0; display:flex; justify-content: space-between; align-items:flex-end; padding: 14px; pointer-events: none; }
    .padcol { display:flex; gap: 12px; pointer-events: none; }
    .btn { pointer-events: auto; width: 80px; height: 80px; border-radius: 20px; border: 0; font-weight:900; font-size:14px; color:#111;
           background: radial-gradient(circle at 30% 30%, #fff, #ddd); box-shadow: 0 8px 24px rgba(0,0,0,.4); }
    .btn:active { transform: scale(0.96); }
    .btn.small { width: 70px; height: 70px; }
    #help { position: fixed; bottom: 8px; left:50%; transform: translateX(-50%); font-size: 12px; opacity: .8; }
    /* Start / End overlays */
    .overlay { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,.55); backdrop-filter: blur(2px); }
    .panel { background: linear-gradient(135deg, #a18cd1, #fbc2eb); color:#111; padding: 18px 20px; border-radius: 18px; box-shadow: 0 10px 30px rgba(0,0,0,.5); width: 90%; max-width: 460px; text-align:center; }
    .panel h1 { margin: 0 0 8px 0; font-size: 28px; }
    .panel p { margin: 6px 0; }
    .panel .big { font-size: 36px; font-weight: 900; margin: 8px 0; }
    .cta { margin-top: 10px; padding: 10px 16px; border-radius: 14px; border: 0; background:#fff; color:#111; font-weight:900; cursor:pointer; }
    /* floating texts */
    .float { position: fixed; color: #fff; font-weight: 900; text-shadow: 0 2px 8px rgba(0,0,0,.6); pointer-events:none; }
    /* mute */
    #mute { position: fixed; right: 10px; top: 10px; pointer-events: auto; border:0; border-radius:14px; padding:8px 10px; font-weight:900; }
  </style>

  <!-- Three.js (non-module) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
</head>
<body>
  <button id="mute">ðŸ”Š Music</button>

  <div id="hud">
    <div id="top">
      <span class="pill">Time: <span id="time">0.00</span>s</span>
      <span class="pill">Snacks: <span id="score">0</span></span>
      <span class="pill">Best time: <span id="best">â€”</span></span>
    </div>
    <div id="msg"></div>
  </div>

  <!-- Touch controls -->
  <div id="controls">
    <div class="padcol">
      <button class="btn" data-action="accel">GO</button>
      <button class="btn" data-action="brake">BRAKE</button>
    </div>
    <div class="padcol">
      <button class="btn small" data-action="left">â—€</button>
      <button class="btn small" data-action="right">â–¶</button>
    </div>
  </div>
  <div id="help">WASD / Arrow keys. On phones, tap buttons.</div>

  <!-- Start overlay -->
  <div id="start" class="overlay">
    <div class="panel">
      <h1>City Street Run</h1>
      <p>Drive through the city, pick up snacks, and cross the finish line as fast as you can.</p>
      <p>Faster car â€¢ longer track â€¢ sharper graphics.</p>
      <button id="startBtn" class="cta">Start</button>
    </div>
  </div>

  <!-- End overlay -->
  <div id="end" class="overlay" style="display:none;">
    <div class="panel">
      <h1>Finish!</h1>
      <div class="big">Time: <span id="finalTime">0.00</span>s</div>
      <p>Snacks collected: <b><span id="finalSnacks">0</span></b></p>
      <p id="endMsg"></p>
      <button id="againBtn" class="cta">Race again</button>
    </div>
  </div>

  <script>
    /* ===== Scene / Camera ===== */
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    // Soft sky gradient
    const sky = new THREE.Mesh(new THREE.SphereGeometry(1000, 24, 16), new THREE.MeshBasicMaterial({ color:0x0c1630, side:THREE.BackSide }));
    scene.add(sky);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0, 8, 18);

    const hemi = new THREE.HemisphereLight(0xbcdcff, 0x2a2a30, 0.6);
    scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(40, 60, 20);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun);

    /* ===== Helpers: textures by code (windows, asphalt, stripes) ===== */
    function makeWindowTexture() {
      const c = document.createElement('canvas'); c.width = 128; c.height = 128;
      const g = c.getContext('2d');
      g.fillStyle = '#4a4d55'; g.fillRect(0,0,128,128);
      for (let y=10; y<128; y+=22){
        for (let x=10; x<128; x+=22){
          g.fillStyle = Math.random()<0.5 ? '#9fd6ff' : '#ffd98a';
          g.globalAlpha = 0.9;
          g.fillRect(x, y, 12, 16);
          g.globalAlpha = 1;
          g.fillStyle = 'rgba(255,255,255,0.15)'; g.fillRect(x, y, 12, 4); // faux glare
        }
      }
      const t = new THREE.CanvasTexture(c);
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.anisotropy = 8;
      return t;
    }
    const windowTex = makeWindowTexture();

    function makeAsphaltTexture() {
      const c = document.createElement('canvas'); c.width=256; c.height=256;
      const g = c.getContext('2d');
      g.fillStyle = '#2f3237'; g.fillRect(0,0,256,256);
      for (let i=0;i<500;i++){
        g.fillStyle = 'rgba(255,255,255,'+(Math.random()*0.06)+')';
        const x=Math.random()*256,y=Math.random()*256,w=Math.random()*2,h=Math.random()*2;
        g.fillRect(x,y,w,h);
      }
      const t = new THREE.CanvasTexture(c); t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(10,80); t.anisotropy=8;
      return t;
    }
    const asphaltTex = makeAsphaltTexture();

    function makeDashTexture() {
      const c = document.createElement('canvas'); c.width=8; c.height=64;
      const g = c.getContext('2d');
      g.fillStyle='#fff';
      g.fillRect(2,0,4,24);
      g.fillRect(2,40,4,24);
      const t = new THREE.CanvasTexture(c); t.wrapS=THREE.RepeatWrapping; t.wrapT=THREE.RepeatWrapping; t.repeat.set(8,200);
      return t;
    }
    const dashTex = makeDashTexture();

    /* ===== Track ===== */
    const ROAD_W = 10;
    const TRACK_LEN = 1600; // long street
    // Road plane
    const roadMat = new THREE.MeshStandardMaterial({ map: asphaltTex, roughness:0.95, metalness:0.02 });
    const road = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W, TRACK_LEN), roadMat);
    road.rotation.x = -Math.PI/2;
    road.position.z = -TRACK_LEN/2;
    road.receiveShadow = true;
    scene.add(road);

    // Lane markings (center dashed + side continuous)
    const centerLine = new THREE.Mesh(new THREE.PlaneGeometry(0.25, TRACK_LEN), new THREE.MeshBasicMaterial({ map: dashTex, transparent:true }));
    centerLine.rotation.x = -Math.PI/2;
    centerLine.position.z = -TRACK_LEN/2;
    scene.add(centerLine);

    function sideLine(x) {
      const m = new THREE.Mesh(new THREE.PlaneGeometry(0.2, TRACK_LEN), new THREE.MeshBasicMaterial({ color:0xffffff }));
      m.rotation.x = -Math.PI/2; m.position.set(x, 0.01, -TRACK_LEN/2); scene.add(m);
    }
    sideLine(-ROAD_W/2+0.7); sideLine( ROAD_W/2-0.7);

    // Pavements
    function curb(x) {
      const m = new THREE.Mesh(new THREE.PlaneGeometry(2.5, TRACK_LEN),
        new THREE.MeshStandardMaterial({ color:0x6b7280, roughness:0.9 }));
      m.rotation.x = -Math.PI/2; m.position.set(x, 0.02, -TRACK_LEN/2); m.receiveShadow = true; scene.add(m);
    }
    curb(-ROAD_W/2-1.5); curb(ROAD_W/2+1.5);

    // Buildings on both sides (window texture)
    const buildings = new THREE.Group(); scene.add(buildings);
    function spawnBuildings() {
      const zStart = -40, zEnd = -TRACK_LEN, step = 20;
      for (let z=zStart; z>zEnd; z-=step) {
        const h1 = THREE.Math.randFloat(8, 22);
        const b1 = new THREE.Mesh(new THREE.BoxGeometry(6, h1, 8),
          new THREE.MeshStandardMaterial({ map: windowTex, roughness:0.6, metalness:0.1 }));
        b1.castShadow = true; b1.receiveShadow=true;
        b1.position.set(-ROAD_W/2-4, h1/2, z + THREE.Math.randFloat(-3,3));
        buildings.add(b1);

        const h2 = THREE.Math.randFloat(8, 22);
        const b2 = new THREE.Mesh(new THREE.BoxGeometry(6, h2, 8),
          new THREE.MeshStandardMaterial({ map: windowTex, roughness:0.6, metalness:0.1 }));
        b2.castShadow = true; b2.receiveShadow=true;
        b2.position.set(ROAD_W/2+4, h2/2, z + THREE.Math.randFloat(-3,3));
        buildings.add(b2);
      }
    }
    spawnBuildings();

    // Finish line banner
    function bannerTextTexture(txt) {
      const c = document.createElement('canvas'); c.width=512; c.height=128;
      const g = c.getContext('2d');
      g.fillStyle='#111'; g.fillRect(0,0,512,128);
      g.fillStyle='#ffd54a'; g.font='bold 64px Arial';
      g.textAlign='center'; g.textBaseline='middle';
      g.fillText(txt, 256, 64);
      const t = new THREE.CanvasTexture(c); t.anisotropy = 8;
      return t;
    }
    const finishZ = -TRACK_LEN + 30;
    const archBar = new THREE.Mesh(new THREE.BoxGeometry(ROAD_W+2, 1.0, 0.6), new THREE.MeshStandardMaterial({ color:0x20242b }));
    archBar.position.set(0, 5, finishZ);
    archBar.castShadow = true; scene.add(archBar);

    const banner = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W*0.9, 2.6), new THREE.MeshStandardMaterial({ map: bannerTextTexture('FINISH'), side:THREE.DoubleSide }));
    banner.position.set(0, 4, finishZ-0.31); banner.rotation.y = Math.PI; banner.castShadow = true; scene.add(banner);

    /* ===== Futuristic car (with glowing strips + LYLA plate) ===== */
    const car = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x6ef0ff, metalness: 0.5, roughness: 0.3, emissive:0x0, emissiveIntensity:0.1 });
    const glowMat = new THREE.MeshStandardMaterial({ color: 0x00fff7, emissive:0x00fff7, emissiveIntensity:1.2, metalness:0.2, roughness:0.2 });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness:0.2, roughness:0.7 });

    // sleek wedge body
    const base = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.5, 3.4), bodyMat); base.position.y=0.6; base.castShadow=true; car.add(base);
    const canopy = new THREE.Mesh(new THREE.SphereGeometry(0.9, 24, 16), darkMat); canopy.scale.set(1.4,0.6,1.1); canopy.position.set(0,1.05,0.1); car.add(canopy);
    // glowing side stripes
    const stripL = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 2.6), glowMat); stripL.position.set(-1.01,0.78,0.1); car.add(stripL);
    const stripR = stripL.clone(); stripR.position.x = 1.01; car.add(stripR);
    // wheels
    function wheel(x,z){ const w=new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,0.3,20), new THREE.MeshStandardMaterial({color:0x222}));
      w.rotation.z=Math.PI/2; w.position.set(x,0.45,z); w.castShadow=true; car.add(w); }
    wheel(-0.9, 1.2); wheel(0.9, 1.2); wheel(-0.9, -1.2); wheel(0.9, -1.2);

    // Back plate texture "LYLA"
    function makePlateTexture() {
      const c = document.createElement('canvas'); c.width=256; c.height=128;
      const g = c.getContext('2d');
      g.fillStyle='#222'; g.fillRect(0,0,256,128);
      g.fillStyle='#fff'; g.font='bold 68px Arial'; g.textAlign='center'; g.textBaseline='middle';
      g.fillText('LYLA', 128, 64);
      const t = new THREE.CanvasTexture(c); t.anisotropy = 8; return t;
    }
    const plate = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.5), new THREE.MeshStandardMaterial({ map: makePlateTexture() }));
    plate.position.set(0, 0.7, -1.8); plate.rotation.y = Math.PI; car.add(plate);

    car.position.set(0, 0.6, 5);
    scene.add(car);

    /* ===== Snacks (burgers, bars, ice creams) along the road ===== */
    function snackBurger(){ const g=new THREE.Group();
      const bunTop=new THREE.Mesh(new THREE.SphereGeometry(0.35,16,12), new THREE.MeshStandardMaterial({color:0xffc27a,roughness:0.7})); bunTop.scale.y=.55; bunTop.position.y=.26; g.add(bunTop);
      const patty=new THREE.Mesh(new THREE.CylinderGeometry(0.36,0.36,0.16,16), new THREE.MeshStandardMaterial({color:0x5a2f18})); patty.position.y=.1; g.add(patty);
      const bunBot=new THREE.Mesh(new THREE.CylinderGeometry(0.38,0.38,0.16,16), new THREE.MeshStandardMaterial({color:0xffc27a,roughness:0.7})); bunBot.position.y=.02; g.add(bunBot);
      return g; }
    function snackBar(){ const g=new THREE.Group();
      const bar=new THREE.Mesh(new THREE.BoxGeometry(0.8,0.18,0.35), new THREE.MeshStandardMaterial({color:0x6b3f1d})); bar.position.y=.12; g.add(bar);
      const wrap=new THREE.Mesh(new THREE.BoxGeometry(0.85,0.02,0.4), new THREE.MeshStandardMaterial({color:0xff6ec7,emissive:0x540a3a,emissiveIntensity:0.2})); wrap.position.y=.22; g.add(wrap); return g;}
    function snackIce(){ const g=new THREE.Group();
      const scoop=new THREE.Mesh(new THREE.SphereGeometry(0.32,18,12), new THREE.MeshStandardMaterial({color:0xffb3d1})); scoop.position.y=.35; g.add(scoop);
      const cone=new THREE.Mesh(new THREE.ConeGeometry(0.22,0.5,12), new THREE.MeshStandardMaterial({color:0xd8a064})); cone.position.y=.06; cone.rotation.x=Math.PI; g.add(cone); return g; }

    const snacks=[]; const snackCount=36;
    function placeSnacks(){
      snacks.forEach(s=>scene.remove(s.group)); snacks.length=0;
      for (let i=0;i<snackCount;i++){
        const t=Math.random();
        const g = t<0.34? snackBurger() : t<0.67? snackBar() : snackIce();
        const laneX = (Math.random()<0.5?-1:1) * THREE.Math.randFloat(1.2, ROAD_W*0.4);
        const z = -THREE.Math.randFloat(60, TRACK_LEN-80);
        g.position.set(laneX, 0.02, -z);
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.02,12),
          new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0x333, emissiveIntensity:0.12 }));
        g.add(base); g.castShadow=true; scene.add(g);
        snacks.push({group:g, active:true, spin:(Math.random()*0.6+0.6)});
      }
    }

    /* ===== Input ===== */
    const keys=new Set();
    addEventListener('keydown', e=>{ keys.add(e.code); });
    addEventListener('keyup',   e=>{ keys.delete(e.code); });

    const pressed={ accel:false, brake:false, left:false, right:false };
    const pointerMap=new Map();
    document.querySelectorAll('.btn').forEach(btn=>{
      const action=btn.dataset.action;
      btn.addEventListener('pointerdown', e=>{ btn.setPointerCapture(e.pointerId); pointerMap.set(e.pointerId, action); pressed[action]=true; });
      function up(e){ const act=pointerMap.get(e.pointerId); if(act) pressed[act]=false; pointerMap.delete(e.pointerId); }
      ['pointerup','pointercancel','pointerout'].forEach(ev=> btn.addEventListener(ev, up));
    });

    /* ===== Audio (arcade loop + sfx) ===== */
    let audioCtx=null, musicGain=null, sfxGain=null, musicOn=true, musicStarted=false;
    function ensureAudio(){
      if (audioCtx) return;
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      musicGain = audioCtx.createGain(); musicGain.gain.value=0.12; musicGain.connect(audioCtx.destination);
      sfxGain   = audioCtx.createGain(); sfxGain.gain.value=0.2;  sfxGain.connect(audioCtx.destination);
      startMusic();
    }
    function startMusic(){
      if (musicStarted||!audioCtx) return; musicStarted=true;
      const tempo=120, beat=60/tempo;
      const bass=[48,48,55,48, 50,50,57,50], lead=[72,76,79,76, 72,76,79,83];
      function f(n){return 440*Math.pow(2,(n-69)/12);}
      function note(freq,dur,time,type='square',gain=0.12){
        const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; o.connect(g); g.connect(musicGain);
        g.gain.setValueAtTime(0,time); g.gain.linearRampToValueAtTime(gain,time+0.01); g.gain.linearRampToValueAtTime(0.0001,time+dur); o.start(time); o.stop(time+dur+0.02);
      }
      function schedule() {
        const t=audioCtx.currentTime; const base=t+0.02;
        for(let i=0;i<8;i++){ note(f(bass[i]), 0.45*beat, base+i*beat,'square',0.12);
          note(f(lead[i]), 0.25*beat, base+i*beat,'triangle',0.1);
          note(f(lead[i]), 0.25*beat, base+i*beat+0.5*beat,'triangle',0.08); }
      }
      setInterval(schedule, beat*2000);
    }
    function pickup(){ if(!audioCtx) return; const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='triangle'; o.connect(g); g.connect(sfxGain);
      const t=audioCtx.currentTime; o.frequency.setValueAtTime(880,t); g.gain.setValueAtTime(0.001,t); g.gain.linearRampToValueAtTime(0.3,t+0.02); g.gain.exponentialRampToValueAtTime(0.001,t+0.25);
      o.start(t); o.stop(t+0.3);
    }
    document.getElementById('mute').addEventListener('click', ()=>{
      ensureAudio(); musicOn=!musicOn; musicGain.gain.value = musicOn?0.12:0.0;
      document.getElementById('mute').textContent = musicOn? 'ðŸ”Š Music' : 'ðŸ”‡ Music';
    });

    /* ===== HUD / state ===== */
    const timeEl=document.getElementById('time');
    const scoreEl=document.getElementById('score');
    const bestEl=document.getElementById('best');
    const startOverlay=document.getElementById('start');
    const endOverlay=document.getElementById('end');
    const finalTimeEl=document.getElementById('finalTime');
    const finalSnacksEl=document.getElementById('finalSnacks');

    let running=false, tStart=0, elapsed=0, score=0;
    let best=Number(localStorage.getItem('LYLA_GAME_BESTTIME')||0);
    function fmt(t){ return t.toFixed(2); }
    function showBest(){ bestEl.textContent = best>0? fmt(best)+'s' : 'â€”'; } showBest();

    function setScore(s){ score=s; scoreEl.textContent=s; }
    function floatText(txt, worldPos, color='#fff'){ const p=worldPos.clone().project(camera);
      const x=(p.x*0.5+0.5)*innerWidth, y=(-p.y*0.5+0.5)*innerHeight;
      const el=document.createElement('div'); el.className='float'; el.textContent=txt; el.style.left=(x-8)+'px'; el.style.top=(y-8)+'px'; el.style.color=color;
      document.body.appendChild(el); let a=0; const id=setInterval(()=>{a++; el.style.transform='translateY('+(-a*1.2)+'px)'; el.style.opacity=String(1-a/40); if(a>=40){clearInterval(id); el.remove();}},16);
    }

    function resetRace(){
      setScore(0);
      elapsed=0;
      car.position.set(0, 0.6, 5);
      car.rotation.set(0,0,0);
      vel.set(0,0,0);
      placeSnacks();
    }

    function begin(){ running=true; resetRace(); startOverlay.style.display='none'; ensureAudio(); tStart=performance.now(); }
    document.getElementById('startBtn').addEventListener('click', begin);
    document.getElementById('againBtn').addEventListener('click', ()=>{ endOverlay.style.display='none'; begin(); });

    /* ===== Driving model (fast + responsive) ===== */
    const vel=new THREE.Vector3(); let verticalVel=0;
    const GRAV=10, ACCEL=30, BRAKE=28, FRICTION=1.8, MAXSPEED=40, TURNSPD=3.4;

    /* ===== Resize ===== */
    addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); });

    /* ===== Main loop ===== */
    let last=performance.now();
    function tick(now){
      const dt=Math.min(0.033,(now-last)/1000); last=now;

      if (running){
        elapsed = (now - tStart)/1000;
        timeEl.textContent = fmt(elapsed);

        // Inputs
        const forward = keys.has('ArrowUp')||keys.has('KeyW')||pressed.accel;
        const back    = keys.has('ArrowDown')||keys.has('KeyS')||pressed.brake;
        const left    = keys.has('ArrowLeft')||keys.has('KeyA')||pressed.left;
        const right   = keys.has('ArrowRight')||keys.has('KeyD')||pressed.right;

        // Accel/brake
        const forwardDir=new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion); // facing -Z
        if (forward) vel.addScaledVector(forwardDir, ACCEL*dt);
        if (back)    vel.addScaledVector(forwardDir, -BRAKE*dt);

        // Speed cap & friction
        if (vel.length()>MAXSPEED) vel.setLength(MAXSPEED);
        vel.multiplyScalar(1 - Math.min(FRICTION*dt, 0.95));

        // Steering (snappy; more at lower speeds)
        const steerInput=(right?1:0)-(left?1:0);
        const speedFactor=Math.min(1, vel.length()/MAXSPEED);
        const assist=0.7 + 0.3*speedFactor;
        car.rotateY(-steerInput*TURNSPD*assist*dt);

        // Move car forward in world
        car.position.addScaledVector(vel, dt);

        // Keep car roughly centered in lateral bounds
        car.position.x = THREE.Math.clamp(car.position.x, -ROAD_W*0.45, ROAD_W*0.45);

        // Camera follow (behind + slightly above)
        const camOffset=new THREE.Vector3(0, 6, 14).applyQuaternion(new THREE.Quaternion()); // static since we look forward
        const camPos = car.position.clone().add(new THREE.Vector3(0,6,14));
        camera.position.lerp(camPos, 1 - Math.pow(0.002, dt));
        camera.lookAt(car.position.x, car.position.y+1.2, car.position.z-6);

        // Snacks spin + pickup
        for (let i=0;i<snacks.length;i++){
          const s=snacks[i]; if(!s.active) continue;
          s.group.rotation.y += dt*s.spin;
          if (s.group.position.distanceTo(car.position) < 1.3){
            s.active=false; s.group.scale.setScalar(1.3); setTimeout(()=>{ s.group.visible=false; }, 80);
            setScore(score+1); floatText('+1', s.group.position);
            pickup();
          }
        }

        // Finish?
        if (car.position.z < finishZ + 3){
          running=false;
          finalTimeEl.textContent = fmt(elapsed);
          finalSnacksEl.textContent = String(score);
          if (best===0 || elapsed < best){ best = elapsed; localStorage.setItem('LYLA_GAME_BESTTIME', String(best)); showBest(); document.getElementById('endMsg').textContent='New best time!'; }
          else { document.getElementById('endMsg').textContent='Nice run!'; }
          endOverlay.style.display='';
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
