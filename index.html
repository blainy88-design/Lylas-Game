<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lyla's Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html, body { height: 100%; margin: 0; background:#0b1320; color:#fff; font-family: system-ui, Arial, sans-serif; touch-action: none; }
    canvas { display:block; }
    /* HUD */
    #hud { position: fixed; inset: 0; pointer-events: none; }
    #top { margin: 10px auto 0; width: max-content; background: linear-gradient(135deg, #ff9a9e, #fad0c4);
           color:#111; padding: 8px 16px; border-radius: 20px; font-weight: 800; box-shadow: 0 4px 18px rgba(0,0,0,.35); }
    #top .pill { background: rgba(255,255,255,.85); padding: 4px 10px; border-radius: 999px; margin: 0 6px; display:inline-block; min-width: 80px; text-align:center; }
    #msg { position: fixed; top: 56px; left: 50%; transform: translateX(-50%); font-weight:700; text-shadow: 0 2px 8px rgba(0,0,0,.6); }
    /* Touch controls */
    #controls { position: fixed; inset: 0; display:flex; justify-content: space-between; align-items:flex-end; padding: 14px; pointer-events: none; }
    .padcol { display:flex; gap: 12px; pointer-events: none; }
    .btn { pointer-events: auto; width: 80px; height: 80px; border-radius: 20px; border: 0; font-weight:900; font-size:14px; color:#111;
           background: radial-gradient(circle at 30% 30%, #fff, #ddd); box-shadow: 0 8px 24px rgba(0,0,0,.4); }
    .btn:active { transform: scale(0.96); }
    .btn.small { width: 70px; height: 70px; }
    #help { position: fixed; bottom: 8px; left:50%; transform: translateX(-50%); font-size: 12px; opacity: .8; }
    /* Start / End overlays */
    .overlay { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,.55); backdrop-filter: blur(2px); }
    .panel { background: linear-gradient(135deg, #a18cd1, #fbc2eb); color:#111; padding: 18px 20px; border-radius: 18px; box-shadow: 0 10px 30px rgba(0,0,0,.5); width: 90%; max-width: 420px; text-align:center; }
    .panel h1 { margin: 0 0 8px 0; font-size: 28px; }
    .panel p { margin: 6px 0; }
    .panel .big { font-size: 36px; font-weight: 900; margin: 8px 0; }
    .cta { margin-top: 10px; padding: 10px 16px; border-radius: 14px; border: 0; background:#fff; color:#111; font-weight:900; cursor:pointer; }
    /* +1 floating text */
    .float { position: fixed; color: #fff; font-weight: 900; text-shadow: 0 2px 8px rgba(0,0,0,.6); pointer-events:none; }
  </style>

  <!-- Three.js + helpers (non-module, stable version) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
</head>
<body>
  <div id="hud">
    <div id="top">
      <span class="pill">Time: <span id="time">90</span>s</span>
      <span class="pill">Score: <span id="score">0</span></span>
      <span class="pill">Best: <span id="best">0</span></span>
    </div>
    <div id="msg"></div>
  </div>

  <!-- Touch controls -->
  <div id="controls">
    <div class="padcol">
      <button class="btn" data-action="accel">GO</button>
      <button class="btn" data-action="brake">BRAKE</button>
    </div>
    <div class="padcol">
      <button class="btn small" data-action="left">◀</button>
      <button class="btn small" data-action="right">▶</button>
    </div>
  </div>
  <div id="help">WASD or Arrow keys. On phones, tap buttons.</div>

  <!-- Start overlay -->
  <div id="start" class="overlay">
    <div class="panel">
      <h1>Welcome to <span style="white-space:nowrap;">Lyla's Game</span></h1>
      <p>Collect as many snacks as you can in 90 seconds.</p>
      <p>Bumps and ditches change how the car feels. Ramps launch you.</p>
      <button id="startBtn" class="cta">Start</button>
    </div>
  </div>

  <!-- End overlay -->
  <div id="end" class="overlay" style="display:none;">
    <div class="panel">
      <h1>Time's up!</h1>
      <div class="big"><span id="finalScore">0</span> snacks</div>
      <p id="endMsg"></p>
      <button id="againBtn" class="cta">Play again</button>
    </div>
  </div>

  <script>
    // ====== Renderer, Scene, Camera ======
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x081225);
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 16);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(18, 26, 12);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun);

    // ====== Arena ======
    const bounds = { minX:-30, maxX:30, minZ:-22, maxZ:22 };
    const W = bounds.maxX - bounds.minX;
    const H = bounds.maxZ - bounds.minZ;

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(W, H, 1, 1),
      new THREE.MeshStandardMaterial({ color: 0x7cc387, roughness: 0.9, metalness: 0.05 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Tarmac corner
    const tarmac = new THREE.Mesh(
      new THREE.PlaneGeometry(W*0.35, H*0.35),
      new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 1 })
    );
    tarmac.rotation.x = -Math.PI/2;
    tarmac.position.set(bounds.maxX - W*0.175, 0.01, bounds.maxZ - H*0.175);
    tarmac.receiveShadow = true;
    scene.add(tarmac);

    // Walls
    function wall(x, z, sx, sz) {
      const m = new THREE.Mesh(
        new THREE.BoxGeometry(sx, 2.5, sz),
        new THREE.MeshStandardMaterial({ color: 0x345, metalness: 0.1, roughness: 0.8 })
      );
      m.position.set(x, 1.25, z);
      m.castShadow = true; m.receiveShadow = true;
      scene.add(m);
    }
    wall(bounds.minX-0.5, 0, 1, H+4);
    wall(bounds.maxX+0.5, 0, 1, H+4);
    wall(0, bounds.minZ-0.5, W+4, 1);
    wall(0, bounds.maxZ+0.5, W+4, 1);

    // Decorative sign "Lyla's Game" outside walls
    const loader = new THREE.FontLoader();
    loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json', function(font) {
      const textGeom = new THREE.TextGeometry("Lyla's Game", {
        font, size: 2.2, height: 0.5, curveSegments: 6,
        bevelEnabled:true, bevelThickness:0.08, bevelSize:0.06, bevelSegments:3
      });
      const textMat = new THREE.MeshStandardMaterial({ color: 0xfff06b, emissive:0x332200, emissiveIntensity:0.35, metalness:0.2, roughness:0.4 });
      const text = new THREE.Mesh(textGeom, textMat);
      text.castShadow = true;
      text.position.set(-7.5, 5, bounds.maxZ + 6.5);
      text.rotation.y = Math.PI; // face inward
      scene.add(text);

      const signBase = new THREE.Mesh(new THREE.BoxGeometry(20, 1, 1.5), new THREE.MeshStandardMaterial({ color: 0x223 }));
      signBase.position.set(0, 3.5, bounds.maxZ + 6.1);
      signBase.castShadow = true; signBase.receiveShadow = true;
      scene.add(signBase);

      const signLight = new THREE.SpotLight(0xffeeaa, 2, 40, Math.PI/6, 0.3, 1);
      signLight.position.set(0, 12, bounds.maxZ + 2.5);
      signLight.target = text;
      signLight.castShadow = true;
      scene.add(signLight);
    });

    // ====== Obstacles ======
    const ditches = [
      { x:-12, z:-8, r:4 },
      { x: 12, z:  6, r:5 },
      { x:  0, z: 12, r:4.5 },
    ];
    ditches.forEach(({x,z,r}) => {
      const ditch = new THREE.Mesh(
        new THREE.CylinderGeometry(r, r, 0.3, 24),
        new THREE.MeshStandardMaterial({ color: 0x355d3a })
      );
      ditch.position.set(x, 0.15, z);
      ditch.receiveShadow = true;
      scene.add(ditch);
    });

    const bumps = [
      { x:-18, z: 10, r:2 },
      { x: 20, z:-10, r:2.5 },
      { x: -4, z: -2, r:1.8 },
    ];
    bumps.forEach(({x,z,r}) => {
      const bump = new THREE.Mesh(
        new THREE.SphereGeometry(r, 20, 12),
        new THREE.MeshStandardMaterial({ color: 0x8fd39a })
      );
      bump.scale.y = 0.3;
      bump.position.set(x, r*0.3, z);
      bump.castShadow = true; bump.receiveShadow = true;
      scene.add(bump);
    });

    function makeRamp(x, z, rotY=0) {
      const geom = new THREE.ConeGeometry(2.2, 1.2, 3);
      const mat = new THREE.MeshStandardMaterial({ color: 0x6ed2ff, metalness:0.1, roughness:0.6 });
      const ramp = new THREE.Mesh(geom, mat);
      ramp.rotation.y = rotY;
      ramp.rotation.x = Math.PI;
      ramp.position.set(x, 0.6, z);
      ramp.castShadow = true; ramp.receiveShadow = true;
      scene.add(ramp);
      return { x, z, w:3.0, d:3.0, rotY, obj: ramp };
    }
    const ramps = [
      makeRamp(-8, 14, Math.PI*0.1),
      makeRamp(16,-4, -Math.PI*0.25),
      makeRamp(-20,-12, Math.PI*0.6),
    ];

    // ====== Car (Yellow Mini-ish, no CapsuleGeometry to keep compatibility) ======
    const car = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffdf00, metalness: 0.3, roughness: 0.4 });
    const roofMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.2, roughness: 0.7 });

    const body = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.6, 2.6), bodyMat);
    body.position.y = 0.55; body.castShadow = true; car.add(body);

    // Rounded ends using scaled spheres
    const nose = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16, 12), bodyMat);
    nose.scale.set(1, 0.8, 1); nose.position.set(0, 0.55, 1.25); car.add(nose);
    const tail = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16, 12), bodyMat);
    tail.scale.set(1, 0.8, 1); tail.position.set(0, 0.55, -1.25); car.add(tail);

    const roof = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 1.6), roofMat);
    roof.position.y = 1.0; car.add(roof);

    function wheel(x, z) {
      const w = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.24, 16), new THREE.MeshStandardMaterial({ color: 0x222222 }));
      w.rotation.z = Math.PI/2;
      w.position.set(x, 0.35, z);
      w.castShadow = true;
      car.add(w);
      return w;
    }
    wheel(-0.8,  1.0); wheel(0.8,  1.0);
    wheel(-0.8, -1.0); wheel(0.8, -1.0);

    // Plate "LYLA"
    const plate = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.18, 0.02), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive:0x222222, emissiveIntensity:0.2 }));
    plate.position.set(0, 0.42, -1.35); car.add(plate);
    const plateText = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.12, 0.01), new THREE.MeshStandardMaterial({ color: 0x111111 }));
    plateText.position.set(0, 0.42, -1.335); car.add(plateText);

    car.position.set(0, 0.5, 0);
    scene.add(car);

    // ====== Snacks ======
    const snackTypes = ['burger', 'bar', 'candy'];
    const snacks = [];
    const snackCount = 24;

    function createBurger() {
      const group = new THREE.Group();
      const bunTop = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 12), new THREE.MeshStandardMaterial({ color: 0xffc27a, roughness:0.7 }));
      bunTop.scale.y = 0.55; bunTop.position.y = 0.26; group.add(bunTop);
      const patty = new THREE.Mesh(new THREE.CylinderGeometry(0.36, 0.36, 0.16, 16), new THREE.MeshStandardMaterial({ color: 0x5a2f18 }));
      patty.position.y = 0.1; group.add(patty);
      const bunBot = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.38, 0.16, 16), new THREE.MeshStandardMaterial({ color: 0xffc27a, roughness:0.7 }));
      bunBot.position.y = 0.02; group.add(bunBot);
      const cheese = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.04, 0.5), new THREE.MeshStandardMaterial({ color: 0xfff06b }));
      cheese.position.y = 0.18; group.add(cheese);
      return group;
    }
    function createBar() {
      const group = new THREE.Group();
      const bar = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.18, 0.35), new THREE.MeshStandardMaterial({ color: 0x6b3f1d }));
      bar.position.y = 0.12; group.add(bar);
      const wrap = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.02, 0.4), new THREE.MeshStandardMaterial({ color: 0xff6ec7, emissive:0x540a3a, emissiveIntensity:0.2 }));
      wrap.position.y = 0.22; group.add(wrap);
      return group;
    }
    function createCandy() {
      const group = new THREE.Group();
      const core = new THREE.Mesh(new THREE.SphereGeometry(0.28, 18, 12), new THREE.MeshStandardMaterial({ color: 0x92f5ff, emissive:0x206a77, emissiveIntensity:0.2 }));
      core.position.y = 0.25; group.add(core);
      const coneMat = new THREE.MeshStandardMaterial({ color: 0xffa6e7, metalness:0.1, roughness:0.5 });
      const left = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.35, 12), coneMat);
      left.rotation.z = Math.PI/2; left.position.set(-0.38, 0.26, 0); group.add(left);
      const right = left.clone(); right.position.x = 0.38; right.rotation.z = -Math.PI/2; group.add(right);
      return group;
    }
    function createSnack() {
      const t = snackTypes[(Math.random()*snackTypes.length)|0];
      let g;
      if (t === 'burger') g = createBurger();
      else if (t === 'bar') g = createBar();
      else g = createCandy();
      const base = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.02, 12), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive:0x333333, emissiveIntensity:0.1 }));
      g.add(base);
      g.castShadow = true;
      return g;
    }
    function randomInArena(margin=2.5) {
      return [
        THREE.Math.randFloat(bounds.minX+margin, bounds.maxX-margin),
        THREE.Math.randFloat(bounds.minZ+margin, bounds.maxZ-margin)
      ];
    }
    function placeSnacks() {
      snacks.forEach(s => scene.remove(s.group));
      snacks.length = 0;
      for (let i=0;i<snackCount;i++) {
        const group = createSnack();
        const p = randomInArena(3.5);
        group.position.set(p[0], 0.02, p[1]);
        scene.add(group);
        snacks.push({ group, active:true, spin: (Math.random()*0.6+0.6) });
      }
    }

    // ====== Input ======
    const keys = new Set();
    addEventListener('keydown', e => { keys.add(e.code); });
    addEventListener('keyup',   e => { keys.delete(e.code); });

    const pressed = { accel:false, brake:false, left:false, right:false };
    const btns = document.querySelectorAll('.btn');
    const pointerMap = new Map();
    function setPressed(action, val) { pressed[action] = val; }
    btns.forEach(btn => {
      const action = btn.dataset.action;
      btn.addEventListener('pointerdown', e => {
        btn.setPointerCapture(e.pointerId);
        pointerMap.set(e.pointerId, action);
        setPressed(action, true);
      });
      btn.addEventListener('pointerup', e => {
        const act = pointerMap.get(e.pointerId);
        if (act) setPressed(act, false);
        pointerMap.delete(e.pointerId);
      });
      btn.addEventListener('pointercancel', e => {
        const act = pointerMap.get(e.pointerId);
        if (act) setPressed(act, false);
        pointerMap.delete(e.pointerId);
      });
      btn.addEventListener('pointerout', e => {
        const act = pointerMap.get(e.pointerId);
        if (act) setPressed(act, false);
        pointerMap.delete(e.pointerId);
      });
    });

    // ====== Game state ======
    const timeEl = document.getElementById('time');
    const scoreEl = document.getElementById('score');
    const bestEl  = document.getElementById('best');
    const msgEl   = document.getElementById('msg');
    const startOverlay = document.getElementById('start');
    const endOverlay = document.getElementById('end');
    const finalScoreEl = document.getElementById('finalScore');
    const endMsgEl = document.getElementById('endMsg');

    let score = 0;
    let best = Number(localStorage.getItem('LYLA_GAME_HISCORE') || 0);
    bestEl.textContent = best;

    let timer = 90;
    let running = false;

    function setScore(s) { score = s; scoreEl.textContent = s; }
    function setTimer(t) { timer = t; timeEl.textContent = Math.max(0, Math.ceil(t)); }

    function showFloatPlusOne(worldPos) {
      const pos = worldPos.clone();
      pos.project(camera);
      const x = (pos.x * 0.5 + 0.5) * innerWidth;
      const y = (-pos.y * 0.5 + 0.5) * innerHeight;
      const el = document.createElement('div');
      el.className = 'float';
      el.textContent = '+1';
      el.style.left = (x-8) + 'px';
      el.style.top = (y-8) + 'px';
      document.body.appendChild(el);
      let a = 0;
      const id = setInterval(() => {
        a += 1;
        el.style.transform = 'translateY(' + (-a*1.2) + 'px)';
        el.style.opacity = String(1 - a/40);
        if (a >= 40) { clearInterval(id); el.remove(); }
      }, 16);
    }

    // Simple beep
    let audioCtx = null;
    function beep() {
      if (!audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'triangle';
      o.frequency.value = 880;
      o.connect(g); g.connect(audioCtx.destination);
      g.gain.value = 0.06;
      o.start();
      setTimeout(() => { o.stop(); }, 120);
    }

    // Fireworks
    const fireworks = [];
    function spawnFireworks(center = new THREE.Vector3(0,4,0), count = 60) {
      for (let i=0;i<count;i++){
        const m = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6) }));
        m.position.copy(center);
        scene.add(m);
        fireworks.push({ m, v: new THREE.Vector3((Math.random()-0.5)*6, Math.random()*4+2, (Math.random()-0.5)*6), life: 1.6 });
      }
    }

    // ====== Physics-ish ======
    const vel = new THREE.Vector3();
    let verticalVel = 0;
    const GRAVITY = 10;

    const baseAccel = 14;
    const baseBrake = 18;
    const baseFriction = 2.4;
    const maxSpeed = 18;
    const turnSpeed = 1.9;

    function resetRound() {
      setScore(0);
      setTimer(90);
      car.position.set(0, 0.5, 0);
      car.rotation.set(0, 0, 0);
      vel.set(0,0,0);
      verticalVel = 0;
      placeSnacks();
      msgEl.textContent = '';
    }

    function begin() {
      running = true;
      resetRound();
      startOverlay.style.display = 'none';
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}
      }
    }

    function endRound() {
      running = false;
      finalScoreEl.textContent = score;
      let text = '';
      if (score > best) {
        best = score;
        localStorage.setItem('LYLA_GAME_HISCORE', String(best));
        bestEl.textContent = best;
        text = 'New high score!';
        spawnFireworks(new THREE.Vector3(0,4,0), 80);
      } else if (score === best && best > 0) {
        text = 'You matched your best!';
      } else {
        text = 'Great driving!';
      }
      endMsgEl.textContent = text;
      endOverlay.style.display = '';
    }

    document.getElementById('startBtn').addEventListener('click', begin);
    document.getElementById('againBtn').addEventListener('click', function() {
      endOverlay.style.display = 'none';
      begin();
    });

    // Resize
    addEventListener('resize', () => {
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    // ====== Main loop ======
    let last = performance.now();
    function tick(now) {
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;

      // Fireworks
      for (let i=fireworks.length-1; i>=0; i--) {
        const f = fireworks[i];
        f.life -= dt;
        f.v.y -= GRAVITY*0.8*dt;
        f.m.position.addScaledVector(f.v, dt);
        f.m.material.emissive = new THREE.Color().setHSL(Math.random(), 0.7, 0.4);
        f.m.material.emissiveIntensity = Math.max(0, f.life);
        if (f.life <= 0) { scene.remove(f.m); fireworks.splice(i,1); }
      }

      if (running) {
        setTimer(timer - dt);
        if (timer <= 0) {
          setTimer(0);
          endRound();
        }

        // Input
        const forward = keys.has('ArrowUp') || keys.has('KeyW') || pressed.accel;
        const back    = keys.has('ArrowDown') || keys.has('KeyS') || pressed.brake;
        const left    = keys.has('ArrowLeft') || keys.has('KeyA') || pressed.left;
        const right   = keys.has('ArrowRight') || keys.has('KeyD') || pressed.right;

        // Obstacle modifiers
        let accel = baseAccel, brake = baseBrake, friction = baseFriction;

        // Ditches
        for (let i=0;i<ditches.length;i++) {
          const d = ditches[i];
          const dx = car.position.x - d.x, dz = car.position.z - d.z;
          const dist = Math.sqrt(dx*dx + dz*dz);
          if (dist < d.r) {
            const t = 1 - dist/d.r;
            accel *= (0.55 + 0.2*t);
            friction *= (1.6 + 1.0*t);
          }
        }
        // Bumps
        for (let i=0;i<bumps.length;i++) {
          const b = bumps[i];
          const dx = car.position.x - b.x, dz = car.position.z - b.z;
          const dist = Math.sqrt(dx*dx + dz*dz);
          if (dist < b.r * 0.9 && verticalVel <= 0.05 && Math.random() < 0.02) {
            verticalVel += 2.0;
          }
        }
        // Ramps
        for (let i=0;i<ramps.length;i++) {
          const r = ramps[i];
          const dx = car.position.x - r.x, dz = car.position.z - r.z;
          if (Math.abs(dx) < r.w && Math.abs(dz) < r.d && verticalVel <= 0.02) {
            verticalVel = 4.0;
            const fdir = new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
            vel.addScaledVector(fdir, 3.5);
          }
        }

        // Movement
        const forwardDir = new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
        if (forward) vel.addScaledVector(forwardDir, accel * dt);
        if (back)    vel.addScaledVector(forwardDir, -brake * dt);

        // Speed/friction
        if (vel.length() > maxSpeed) vel.setLength(maxSpeed);
        vel.multiplyScalar(1 - Math.min(friction*dt, 0.95));

        // Steering
        const steerInput = (right?1:0) - (left?1:0);
        const speedFactor = THREE.Math.clamp ? THREE.Math.clamp(vel.length()/maxSpeed, 0, 1) : Math.min(1, Math.max(0, vel.length()/maxSpeed));
        car.rotateY(-steerInput * turnSpeed * (0.3 + 0.7*speedFactor) * dt);

        // Apply motion
        car.position.addScaledVector(vel, dt);

        // Vertical motion
        verticalVel -= GRAVITY * dt;
        car.position.y += verticalVel * dt;
        const groundY = 0.5;
        if (car.position.y < groundY) {
          car.position.y = groundY;
          verticalVel = 0;
        }

        // Walls soft bounce
        if (car.position.x < bounds.minX+0.9) { car.position.x = bounds.minX+0.9; vel.x = Math.abs(vel.x)*0.3; }
        if (car.position.x > bounds.maxX-0.9) { car.position.x = bounds.maxX-0.9; vel.x = -Math.abs(vel.x)*0.3; }
        if (car.position.z < bounds.minZ+0.9) { car.position.z = bounds.minZ+0.9; vel.z = Math.abs(vel.z)*0.3; }
        if (car.position.z > bounds.maxZ-0.9) { car.position.z = bounds.maxZ-0.9; vel.z = -Math.abs(vel.z)*0.3; }

        // Camera follow
        const camOffset = new THREE.Vector3(0, 9, -14).applyQuaternion(car.quaternion);
        const desired = car.position.clone().add(camOffset);
        camera.position.lerp(desired, 1 - Math.pow(0.002, dt));
        camera.lookAt(car.position.x, car.position.y + 1.2, car.position.z);

        // Snacks
        for (let i=0;i<snacks.length;i++) {
          const s = snacks[i];
          if (!s.active) continue;
          s.group.rotation.y += dt * s.spin;
          if (s.group.position.distanceTo(car.position) < 1.4) {
            s.active = false;
            s.group.scale.setScalar(1.3);
            setTimeout(function(){ s.group.visible = false; }, 80);
            setScore(score + 1);
            showFloatPlusOne(s.group.position.clone());
            beep();
          }
        }

        if (Math.abs(steerInput) === 0 && vel.length() < 2 && timer > 85) {
          msgEl.textContent = 'Hold GO and tap ◀ ▶ to steer';
        } else {
          msgEl.textContent = '';
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
